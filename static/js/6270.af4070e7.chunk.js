"use strict";(self.webpackChunktyphoon=self.webpackChunktyphoon||[]).push([[6270],{95776:(e,t,s)=>{s.d(t,{A:()=>n,J:()=>i});var r=s(88685);function i(e,t){let s;if("string"==typeof e)s=(0,r.Wm)(e+"-seed(".concat(t,")"));else{let r=12;s=e^t;do{s=107*(s>>8^s)+r|0}while(0!=--r)}return(1+s/(1<<31))/2}function n(e){return Math.floor(i(e,a)*o)}const a=53290320,o=10},96270:(e,t,s)=>{s.d(t,{o:()=>ie});var r=s(32743),i=s(81320),n=s(13308),a=s(33346),o=s(13720),c=s(38550),l=s(9410),h=s(57156),u=s(98112),d=s(87663),m=s(76931),f=s(94967),p=s(98006),_=s(19555),g=s(59422),v=s(72745),y=s(98618),x=s(1484),M=s(71447),P=s(23758),w=s(19358),b=s(19385),I=s(77555);function S(e,t,s){return e[0]=t[0]-s[0],e[1]=t[1]-s[1],e}function L(e,t){return Math.sqrt(e*e+t*t)}function k(e){const t=L(e[0],e[1]);e[0]/=t,e[1]/=t}function z(e,t){return L(e[0]-t[0],e[1]-t[1])}function A(e){return e.length-1}function B(e){let t=0;for(let s=0;s<A(e);s++)t+=E(e,s);return t}function E(e,t){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,[r,i]=function(e,t){return e[t+1]}(e,t);return[r,i]=[Math.round(r),Math.round(i)],Math.sqrt(r*r+i*i)*s}class D{constructor(e,t,s,r,i){this._segments=e,this._index=t,this._distance=s,this._xStart=r,this._yStart=i,this._done=!1}static create(e){return new D(e,0,0,e[0][0],e[0][1])}clone(){return new D(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(e){return this._index===e._index||e._index===this._index-1&&(0===this._distance||1===e._distance)||e._index===this._index+1&&(1===this._distance||0===e._distance)}leq(e){return this._index<e._index||this._index===e._index&&this._distance<=e._distance}geq(e){return this._index>e._index||this._index===e._index&&this._distance>=e._distance}get _segment(){return this._segments[this._index+1]}get angle(){const e=this.dy,t=(0*e+-1*-this.dx)/(1*this.length);let s=Math.acos(t);return e>0&&(s=2*Math.PI-s),s}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:e,dy:t}=this;return Math.sqrt(e*e+t*t)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<A(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(e,t){const s=this.backwardLength;if(e<=s)return this._distance=(s-e)/this.length,this;let r=this.backwardLength;for(;this.prev();){if(r+this.length>e)return this._seekBackwards(e-r);r+=this.length}return this._distance=0,t?this:null}seek(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(e<0)return this._seekBackwards(Math.abs(e),t);if(e<=this.remainingLength)return this._distance=(this.backwardLength+e)/this.length,this;let s=this.remainingLength;for(;this.next();){if(s+this.length>e)return this.seek(e-s,t);s+=this.length}return this._distance=1,t?this:null}}function G(e,t,s){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const i=B(e),n=D.create(e),a=i/2;if(!r)return n.seek(a),void(Math.abs(n.x)<I.s&&Math.abs(n.y)<I.s&&s(n.clone(),0,a+0*t,i));const o=Math.max((i-t)/2,0),c=Math.floor(o/t),l=a-c*t;n.seek(l);for(let h=-c;h<=c;h++)Math.abs(n.x)<I.s&&Math.abs(n.y)<I.s&&s(n.clone(),h,a+h*t,i),n.seek(t)}function R(e,t){const s=t;for(let r=0;r<e.length;r++){let t=e[r];N(t,s);const i=[];i.push(t[0]);for(let e=1;e<t.length;e++){const[s,r]=t[e-1],[n,a]=t[e],o=n-s,c=a-r;i.push([o,c])}e[r]=i,t=i}return e}function N(e,t){const s=1e-6;if(t<=0)return;const r=e.length;if(r<3)return;const i=[];let n=0;i.push(0);for(let u=1;u<r;u++)n+=z(e[u],e[u-1]),i.push(n);t=Math.min(t,.2*n);const a=[];a.push(e[0][0]),a.push(e[0][1]);const o=e[r-1][0],c=e[r-1][1],l=S([0,0],e[0],e[1]);k(l),e[0][0]+=t*l[0],e[0][1]+=t*l[1],S(l,e[r-1],e[r-2]),k(l),e[r-1][0]+=t*l[0],e[r-1][1]+=t*l[1];for(let u=1;u<r;u++)i[u]+=t;i[r-1]+=t;const h=.5*t;for(let u=1;u<r-1;u++){let n=0,o=0,c=0;for(let r=u-1;r>=0&&!(i[r+1]<i[u]-h);r--){const a=h+i[r+1]-i[u],l=i[r+1]-i[r],d=i[u]-i[r]<h?1:a/l;if(Math.abs(d)<s)break;const m=d*d,f=d*a-.5*m*l,p=d*l/t,_=e[r+1],g=e[r][0]-_[0],v=e[r][1]-_[1];n+=p/f*(_[0]*d*a+.5*m*(a*g-l*_[0])-m*d*l*g/3),o+=p/f*(_[1]*d*a+.5*m*(a*v-l*_[1])-m*d*l*v/3),c+=p}for(let a=u+1;a<r&&!(i[a-1]>i[u]+h);a++){const r=h-i[a-1]+i[u],l=i[a]-i[a-1],d=i[a]-i[u]<h?1:r/l;if(Math.abs(d)<s)break;const m=d*d,f=d*r-.5*m*l,p=d*l/t,_=e[a-1],g=e[a][0]-_[0],v=e[a][1]-_[1];n+=p/f*(_[0]*d*r+.5*m*(r*g-l*_[0])-m*d*l*g/3),o+=p/f*(_[1]*d*r+.5*m*(r*v-l*_[1])-m*d*l*v/3),c+=p}a.push(n/c),a.push(o/c)}a.push(o),a.push(c);for(let u=0,d=0;u<r;u++)e[u][0]=a[d++],e[u][1]=a[d++]}var Z=s(28736),T=s(81615);const F=(0,d.Bj)((e=>{let t=0;if(0===e)return 1/0;for(;!(e%2);)t++,e/=2;return t}));class O extends T.G8{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,s,r){if(this._zoomLevel=r||0,null!=s)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const s=t.readXForDisplay(),r=t.readYForDisplay();return this._writePoint(e,s,r,t)}case"esriGeometryEnvelope":case"esriGeometryPolygon":case"esriGeometryMultipoint":{const s=t.readCentroidForDisplay();if(!s)return;const[r,i]=s.coords;return this._writePoint(e,r,i,t)}case"esriGeometryPolyline":this._writeLines(e,t)}}_writePoint(e,t,s,r){var i,n,a,o;const c=this._getShaping();if(!c)return;let l=this._getPointReferenceBounds();l||(l={offsetX:0,offsetY:0,size:0});const h=c.boundsT,u=(0,M.xy)(this.evaluatedMeshParams.horizontalAlignment),d=(0,M.UD)(this.evaluatedMeshParams.verticalAlignment),m=null!==(i=null===(n=this.evaluatedMeshParams.scaleInfo)||void 0===n?void 0:n.maxScale)&&void 0!==i?i:0,f=null!==(a=null===(o=this.evaluatedMeshParams.scaleInfo)||void 0===o?void 0:o.minScale)&&void 0!==a?a:0,p=(0,P.Q4)(r.getDisplayId());e.metricStart(new b.f(p,t,s,u,d,m,f,l)),e.metricBoxWrite(h),this._writeGlyphs(e,r.getDisplayId(),t,s,c,0,l),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){const{scaleInfo:s,verticalAlignment:r}=this.evaluatedMeshParams,i=this.evaluatedMeshParams.repeatLabelDistance||128,n=this._getShaping("middle");if(!n)return;const a=(e,t,s,r)=>this._placeSubdivGlyphs(e,t,s,r),o=(n.bounds.width+i)/2;this._current={out:e,id:t.getDisplayId(),shaping:n,zoomRange:(0,Z.My)(s,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null},this._verticalPlacement="bottom"===r?"above":"top"===r?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,a,o):this._writeCenterAlong(t,a,o)}_writeAboveAndBelowAlong(e,t,s){const{repeatLabel:r,fontSize:i}=this.evaluatedMeshParams,{shaping:n}=this._current,a=(0,m.Lz)(i),o=e.readGeometryForDisplay();if(!o)return;const c=new x.A;(0,y.kz)(c,o,!1,!1,"esriGeometryPolyline",1);const l=V(new x.A,c,a),h=V(new x.A,c,-a),u=(0,y.zv)(h,"esriGeometryPolyline",!1,!1),d=R((0,y.zv)(l,"esriGeometryPolyline",!1,!1).paths,n.bounds.width),f=R(u.paths,n.bounds.width);this._current.offsetDirection="above";for(const m of d)G(m,s,t,!!r);this._current.offsetDirection="below";for(const m of f)G(m,s,t,!!r)}_writeCenterAlong(e,t,s){const{repeatLabel:r}=this.evaluatedMeshParams,{shaping:i}=this._current,n=R(e.readLegacyGeometryForDisplay().paths,i.bounds.width);for(const a of n)G(a,s,t,!!r)}_placeSubdivGlyphs(e,t,s,r){const{allowOverrun:i,labelPosition:n,repeatLabelDistance:a}=this.evaluatedMeshParams,o=this._current.zoomRange[0],c=F(t),l=this._current.shaping.bounds.width/2,h=Math.sqrt(a||128)/2,u=Math.min(s,r-s),d=this._current.shaping.isMultiline?T.GJ:Math.log2(u/(h+l/2)),m=0===t?d:Math.min(c,d),f=Math.max(o,this._zoomLevel+1-m),p=this._zoomLevel-f,_=this._current.shaping.bounds.width/2*2**p;this._current.shaping.isMultiline?0===t&&this._placeStraight(e,f):i&&p<0?this._placeStraightAlong(e,o):"parallel"===n?this._placeStraightAlong(e,f):"curved"===n&&this._placeCurved(e,f,_)}_placeStraight(e,t){var s,r,i,n;const{out:a,id:o,shaping:c,referenceBounds:l}=this._current,{x:h,y:u}=e,d=(0,P.Q4)(o),m=null!==(s=null===(r=this.evaluatedMeshParams.scaleInfo)||void 0===r?void 0:r.maxScale)&&void 0!==s?s:0,f=null!==(i=null===(n=this.evaluatedMeshParams.scaleInfo)||void 0===n?void 0:n.minScale)&&void 0!==i?i:0;a.metricStart(new b.f(d,e.x,e.y,0,0,m,f,null)),a.metricBoxWrite(c.boundsT);const p=e.angle*(180/Math.PI)%360,_=(e.angle*(180/Math.PI)+180)%360;this._writeGlyphs(a,o,h,u,c,0,l,{clipAngle:p,mapAligned:!0,isLineLabel:!0,minZoom:t}),this._writeGlyphs(a,o,h,u,c,0,l,{clipAngle:_,mapAligned:!0,isLineLabel:!0,minZoom:t}),a.metricEnd()}_placeCurved(e,t,s){var r,i,n,a;const{out:o,id:c}=this._current,l=e.clone(),h=e.angle*(180/Math.PI)%360,u=(e.angle*(180/Math.PI)+180)%360,d=(0,P.Q4)(c),m=null!==(r=null===(i=this.evaluatedMeshParams.scaleInfo)||void 0===i?void 0:i.maxScale)&&void 0!==r?r:0,f=null!==(n=null===(a=this.evaluatedMeshParams.scaleInfo)||void 0===a?void 0:a.minScale)&&void 0!==n?n:0;o.metricStart(new b.f(d,e.x,e.y,0,0,m,f,null)),this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(l,t,1,h),this._placeBack(e,l,t,s,1,h),this._placeForward(e,l,t,s,1,h)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(l,t,0,u),this._placeBack(e,l,t,s,0,u),this._placeForward(e,l,t,s,0,u)),o.metricEnd()}_placeStraightAlong(e,t){var s,r,i,n;const{out:a,id:o,shaping:c,zoomRange:l,referenceBounds:h}=this._current,{boxBorderLineColor:u,boxBackgroundColor:d}=this.evaluatedMeshParams,_=e.clone(),v=e.angle*(180/Math.PI)%360,y=(e.angle*(180/Math.PI)+180)%360;if(c.glyphs.length>0&&(u||d)){const s=Math.max(t,l[0],0),r=Math.min(T.GJ,l[1]),i=(0,f.$0)((0,p.vt)(),-e.angle),n={minZoom:s,maxZoom:r,clipAngle:v,mapAligned:!0,isLineLabel:!0},u=(0,m.Lz)(this.evaluatedMeshParams.offsetX),d=(0,m.Lz)(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const t=(0,g.fA)(u,-1*d),[s,r]=c.shapeBackground((0,f.Tl)((0,p.vt)(),i,t));a.recordStart(this.instanceId,this.attributeLayout,c.glyphs[0].textureBinding);const l=2*Math.max(s.width,s.height);a.recordBounds(e.x+s.x,e.y+s.y,l,l),this._writeTextBox(a,o,e.x,e.y,r,h,n),a.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const t=(0,g.fA)(u,d),[s,r]=c.shapeBackground((0,f.Tl)((0,p.vt)(),i,t));n.clipAngle=y,a.recordStart(this.instanceId,this.attributeLayout,c.glyphs[0].textureBinding);const l=2*Math.max(s.width,s.height);a.recordBounds(e.x+s.x,e.y+s.y,l,l),this._writeTextBox(a,o,e.x,e.y,r,h,n),a.recordEnd()}}const x=(0,P.Q4)(o),M=null!==(s=null===(r=this.evaluatedMeshParams.scaleInfo)||void 0===r?void 0:r.maxScale)&&void 0!==s?s:0,w=null!==(i=null===(n=this.evaluatedMeshParams.scaleInfo)||void 0===n?void 0:n.minScale)&&void 0!==i?i:0;a.metricStart(new b.f(x,e.x,e.y,0,0,M,w,null)),this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(_,t,1,v,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(_,t,0,y,!0),a.metricEnd()}_placeBack(e,t,s,r,i,n){const a=e.clone();let o=e.backwardLength+0;for(;a.prev()&&!(o>=r);)this._placeOnSegment(a,t,o,s,-1,i,n),o+=a.length+0}_placeForward(e,t,s,r,i,n){const a=e.clone();let o=e.remainingLength+0;for(;a.next()&&!(o>=r);)this._placeOnSegment(a,t,o,s,1,i,n),o+=a.length+0}_placeFirst(e,t,s,r){let i=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const{out:n,id:a,shaping:o,zoomRange:c,referenceBounds:l}=this._current,h=o.glyphs;for(const u of h){const h=u.x>o.bounds.x?s:1-s,d=h*e.remainingLength+(1-h)*e.backwardLength,m=Math.abs(u.x+u.width/2-o.bounds.x),f=Math.max(0,this._zoomLevel+Math.log2(m/(d+0))),p=Math.max(t,i?0:f);u.maxZoom=Math.min(c[1],T.GJ),u.angle=e.angle+(1-s)*Math.PI,u.minZoom=Math.max(c[0],p),this._writeLineGlyph(n,a,e.x,e.y,o.bounds,u,r,l,!0),s&&this._isVisible(u.minZoom,u.maxZoom)&&n.metricBoxWrite(u.bounds)}}_placeOnSegment(e,t,s,r,i,n,a){const{out:o,id:c,shaping:l,referenceBounds:h}=this._current,u=l.glyphs,d=e.dx/e.length,m=e.dy/e.length,f={x:e.x+s*-i*d,y:e.y+s*-i*m};for(const p of u){const u=p.x>l.bounds.x?n:1-n;if(!(u&&1===i||!u&&-1===i))continue;const d=Math.abs(p.x+p.width/2-l.bounds.x),m=Math.max(0,this._zoomLevel+Math.log2(d/s)-.1),_=Math.max(r,this._zoomLevel+Math.log2(d/(s+e.length+0)));if(0!==m&&(p.angle=e.angle+(1-n)*Math.PI,p.minZoom=_,p.maxZoom=m,this._writeLineGlyph(o,c,f.x,f.y,l.bounds,p,a,h,!0),n&&this._isVisible(p.minZoom,p.maxZoom))){const s=p.bounds,r=e.x-t.x,i=e.y-t.y,n=new w.A(s.center[0]+r,s.center[1]+i,s.width,s.height);o.metricBoxWrite(n)}}}_writeLineGlyph(e,t,s,r,i,n,a,o,c){const l=s+i.x,h=r+i.y,u=2*(this.evaluatedMeshParams.minPixelBuffer?this.evaluatedMeshParams.minPixelBuffer/this._textMeshTransformProps.fontSize:1),d=Math.max(i.width,i.height)*u;e.recordStart(this.instanceId,this.attributeLayout,n.textureBinding),e.recordBounds(l,h,d,d);const{texcoords:m,offsets:f}=n,p=this._textMeshTransformProps.fontSize;this._writeQuad(e,t,s,r,{texcoords:m,offsets:f,fontSize:p,color:(0,Z.Jb)(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:o,minZoom:Math.max(this._current.zoomRange[0],n.minZoom),maxZoom:Math.min(this._current.zoomRange[1],n.maxZoom),clipAngle:a,mapAligned:c,isLineLabel:!0}),e.recordEnd()}_isVisible(e,t){const s=this._zoomLevel;return e<=s&&s<=t}}function V(e,t,s){const{coords:r,lengths:i}=t,n=(0,v.vt)(),a=(0,v.vt)(),o=(0,v.vt)(),c=(0,v.vt)(),l=(0,v.vt)(),h=(0,v.vt)();let u=0;for(let d=0;d<i.length;d++){const t=i[d];for(let i=0;i<t;i++){const d=2*(i+u-1),m=2*(i+u),f=2*(i+u+1);i>0?(0,_.hZ)(n,r[d],r[d+1]):(0,_.hZ)(n,0,0),(0,_.hZ)(a,r[m],r[m+1]),i<t-1?(0,_.hZ)(o,r[f],r[f+1]):(0,_.hZ)(o,0,0),0===i?(0,_.hZ)(c,0,0):((0,_.jb)(c,a,n),(0,_.S8)(c,c),(0,_.hZ)(c,c[1],-c[0])),i===t-1?(0,_.hZ)(l,0,0):((0,_.jb)(l,o,a),(0,_.S8)(l,l),(0,_.hZ)(l,l[1],-l[0])),(0,_.WQ)(h,c,l),(0,_.S8)(h,h);const p=h[0]*l[0]+h[1]*l[1];0!==p&&(0,_.hs)(h,h,p),(0,_.hs)(h,h,s),e.coords.push(a[0]+h[0],a[1]+h[1])}e.lengths.push(t),u+=t}return e}var W=s(64346),C=s(26455),j=s(4480),q=s(18690),Q=s(50076),J=s(53084),Y=s(76460),X=s(95776),H=s(27534),K=s(74014);async function U(e,t){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const{defaultValue:r,valueExpressionInfo:i,value:n}=t;if(i){const{expression:n}=i,a=await e.createComputedField({expression:n},s);return a?{...t,computed:a,defaultValue:r}:null}return{...t,computed:new K.G(n),defaultValue:r}}async function $(e,t){const{defaultValue:s,valueExpressionInfo:r}=t,{expression:i}=r,n=await e.createComputedField({expression:i});return n?{...t,computed:n,defaultValue:s}:null}const ee=e=>"boolean"!=typeof e&&"number"!=typeof e&&"valueExpressionInfo"in e,te=e=>e.some((e=>{for(const t in e){const s=e[t];if(ee(s))return!0}return!1}));class se{static async create(e,t,s){const r={},i=new Map,n=new Map,a=new Map,o=new Map,c=new Map;for(const u in s){const d=s[u];if(null!=d&&"object"==typeof d)if(Array.isArray(d)){if("object"==typeof d[0])throw new Error("InternalError: Cannot handle ".concat(u,". Nested array params are not supported"));r[u]=d}else if("valueExpressionInfo"in d){if(d.value){r[u]=d.value;continue}const t=await $(e,d);if(!t){r[u]=d.defaultValue;continue}i.set(u,t),r[u]=null}else switch(d.type){case"cim-effect-infos":if(d.effectInfos.some((e=>e.overrides.length))){n.set(u,{effects:await Promise.all(d.effectInfos.map((async t=>{const s=t.overrides.map((t=>U(e,t)));return{effect:t.effect,compiledOverrides:(await Promise.all(s)).filter(q.Ru)}})))});break}r[u]=d.effectInfos.map((e=>e.effect));break;case"cim-marker-placement-param":d.overrides.length&&a.set(u,{placementInfo:d,compiledOverrides:(await Promise.all(d.overrides.map((t=>U(e,t))))).filter(q.Ru)}),r[u]=d.placement;break;case"text-rasterization-param":{var l;if(d.overrides.length){const t=d.overrides.map((t=>U(e,t,d.useLegacyLabelEvaluationRules)));o.set(u,{compiledOverrides:(await Promise.all(t)).filter(q.Ru),rasterizationParam:d,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:d.resource};r[u]=null!==(l=await t.fetchResourceImmediate(s))&&void 0!==l?l:null;break}case"sprite-rasterization-param":{var h;if(d.overrides.length){const t=d.overrides.map((t=>U(e,t)));o.set(u,{compiledOverrides:(await Promise.all(t)).filter(q.Ru),rasterizationParam:d,objectIdToResourceId:new Map});continue}if("animated"===d.resource.type){o.set(u,{compiledOverrides:[],rasterizationParam:d,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:d.resource};r[u]=null!==(h=await t.fetchResourceImmediate(s))&&void 0!==h?h:null;break}case"cim-marker-transform-param":{const{params:t}=d;if(te(t)){const s={compiledMarkerInfos:[]};await Promise.all(t.map((async t=>{const r={props:{}};for(const s in t)if(ee(t[s])){const i=await $(e,t[s]);r.compiledExpressionMap||(r.compiledExpressionMap=new Map);const n=r.compiledExpressionMap;i&&n.set(s,i)}else r.props[s]=t[s];s.compiledMarkerInfos.push(r)}))),c.set(u,s)}else r[u]={type:"cim-marker-transform-info",infos:t};break}default:r[u]=d}else r[u]=d}return new se(s,r,i,n,a,o,c)}constructor(e,t,s,r,i,n,a){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=s,this._dynamicEffectProperties=r,this._dynamicPlacementProperties=i,this._dynamicAsyncProperties=n,this._dynamicTransformProperties=a,this.evaluator=e=>e}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,s){for(const r of this._dynamicAsyncProperties.values()){const i=(0,J.o8)(r.rasterizationParam.resource);"animated"===r.rasterizationParam.resource.type&&r.rasterizationParam.resource.randomizeStartTime&&(i.primitiveName="__RESERVED__PRIMITIVE__NAME__",i.startGroup=(0,X.A)(t.getObjectId()||0));for(const{primitiveName:e,propertyName:a,computed:o,defaultValue:c,valueExpressionInfo:l}of r.compiledOverrides)try{const n="animated"===r.rasterizationParam.resource.type?i.primitiveName:e;(0,H.Ph)(i,n,a,o,t,s,c)}catch(E){Y.A.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator").errorOnce(new Q.A("invalid-arcade-expression","Encountered an error when evaluating the arcade expression '".concat(null===l||void 0===l?void 0:l.expression,"' (primitive: '").concat(e,"', property: '").concat(a,"')"),E))}const n=e.enqueueRequest({type:"cim-rasterization-info",resource:i});r.objectIdToResourceId.set(t.getObjectId(),n)}}evaluateMeshParams(e,t,s){for(const[r,i]of this._dynamicProperties.entries())this._resolvedMeshParams[r]=i.computed.readWithDefault(t,s,i.defaultValue);for(const[r,i]of this._dynamicPlacementProperties.entries())for(const{computed:e,defaultValue:n,propertyName:a}of i.compiledOverrides){const o=e.readWithDefault(t,s,n);i.placementInfo.placement[a]=o,this._resolvedMeshParams[r]=i.placementInfo.placement}for(const[r,i]of this._dynamicEffectProperties.entries())for(const e of i.effects){for(const{computed:r,defaultValue:i,propertyName:n}of e.compiledOverrides){const a=r.readWithDefault(t,s,i);e.effect[n]=a}this._resolvedMeshParams[r]=i.effects.map((e=>e.effect))}for(const[r,i]of this._dynamicTransformProperties.entries()){const e={type:"cim-marker-transform-info",infos:[]};for(const r of i.compiledMarkerInfos){const i={...r.props};if(r.compiledExpressionMap)for(const[e,n]of r.compiledExpressionMap){const r=n.computed.readWithDefault(t,s,n.defaultValue);i[e]="number"==typeof r||"boolean"==typeof r?r:n.defaultValue}e.infos.push(i)}this._resolvedMeshParams[r]=e}for(const[r,i]of this._dynamicAsyncProperties.entries()){const s=i.objectIdToResourceId.get(t.getObjectId());if(null==s)continue;const n=e.getResource(s);this._resolvedMeshParams[r]=n}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}}var re=s(41406);class ie{async createMeshWriter(e,t,s,r){const i=this._getMeshWriter(r.techniqueType),n=await se.create(e,t,r.inputParams),a=new i(r.id,n,r.optionalAttributes,s);return await a.loadDependencies(),a}_getMeshWriter(e){switch(e){case r.N.Fill:return o.Y;case r.N.DotDensity:return i.k;case r.N.ComplexFill:return n.KE;case r.N.PatternFill:return l.m;case r.N.OutlineFill:return c.w0;case r.N.PatternOutlineFill:return h.Q;case r.N.ComplexOutlineFill:return a.O;case r.N.Marker:return j.H;case r.N.PieChart:return re.v;case r.N.Text:return T.G8;case r.N.Line:return W.Bw;case r.N.TexturedLine:return C.K;case r.N.Heatmap:return u.h;case r.N.Label:return O;case r.N.Test:throw new Error("Internal Error: Found invalid mesh writer")}}}},74014:(e,t,s)=>{s.d(t,{G:()=>i});var r=s(33219);class i extends r.L{constructor(e){super(),this._value=e}resize(e){}read(e,t){return this._value}readWithDefault(e,t,s){return this._value}referencesScale(){return!1}referencesGeometry(){return!1}}}}]);
//# sourceMappingURL=6270.af4070e7.chunk.js.map